#' @name plotCorrelation
#' @inherit AcidGenerics::plotCorrelation
#' @note Updated 2021-08-09.
#'
#' @section Correlation coefficient calculations:
#'
#' Correlation coefficient calcluations are generated by
#' `ggpmisc::stat_poly_eq()`. Refer to the
#' [ggpmisc GitHub repo](https://github.com/aphalo/ggpmisc) for details.
#'
#' @inheritParams AcidRoxygen::params
#' @param xCol,yCol `character(1)` or `integer(1)`.
#'   X and Y column name or position.
#' @param labelCol `character(1)` or NULL.
#'   For `data.frame` method, which column should be used to label points
#'   on the plot?
#' @param r2 `logical(1)`.
#'   Show information on the `lm` fit?
#'   This includes the equation, and the coefficient of determination (R^2).
#'   Refer to `ggpmisc::stat_poly_eq` for details.
#' @param se `logical(1)`.
#'   Display confidence interval around the `lm` fit line?
#'   Refer to `ggplot2::geom_smooth` for details.
#' @param colors `list(3)`.
#'   Named list defining the colors of `dots`, `line`, and `se`, for confidence
#'   interval standard error.
#' @param ... Additional arguments.
#'
#' @seealso
#' - `ggpmisc::stat_poly_eq`.
#' - `ggplot2::geom_smooth`.
#'
#' @examples
#' data(RangedSummarizedExperiment, package = "AcidTest")
#'
#' ## SummarizedExperiment ====
#' object <- RangedSummarizedExperiment
#' plotCorrelation(
#'     object = object,
#'     xCol = 1L,
#'     yCol = 2L,
#'     trans = "identity"
#' )
NULL



## Updated 2021-05-17.
`plotCorrelation,matrix` <-  # nolint
    function(
        object,
        xCol,
        yCol,
        label = FALSE,
        labels = NULL,
        trans = c("log10", "log2", "identity"),
        r2 = TRUE,
        se = TRUE,
        colors = list(
            "dots" = "black",
            "line" = "black",
            "se" = "gray"
        )
    ) {
        validObject(object)
        assert(
            hasColnames(object),
            hasRows(object),
            isString(xCol) || isInt(xCol),
            isString(yCol) || isInt(yCol),
            isFlag(label),
            isFlag(r2),
            isFlag(se),
            is.list(colors),
            areSetEqual(
                x = names(colors),
                y = names(eval(formals()[["colors"]]))
            )
        )
        if (isFALSE(se)) {
            colors[["se"]] <- NA
        }
        trans <- match.arg(trans)
        isLog <- !identical(trans, "identity")
        object <- as.data.frame(object[, c(xCol, yCol)])
        labels <- matchLabels(labels)
        if (is.null(labels[["x"]])) {
            labels[["x"]] <- colnames(object)[[1L]]
        }
        if (is.null(labels[["y"]])) {
            labels[["y"]] <- colnames(object)[[2L]]
        }
        labs <- do.call(what = labs, args = labels)
        assert(is(labs, "labels"))
        data <- tibble("x" = object[[xCol]], "y" = object[[yCol]])
        if (isTRUE(label)) {
            assert(
                ## NOTE Not using `hasRownames` check here, because edge case
                ## integer values are OK here. Consider updating the assert
                ## in goalie package to allow for integer row names in matrix
                ## and DataFrame classes, but not data.frame only.
                ## > hasRownames(object),
                isCharacter(rownames(object)),
                nrow(object) <= 50L
            )
            data[["label"]] <- rownames(object)
        }
        data <- data[complete.cases(data), , drop = FALSE]
        assert(hasRows(data))
        if (isTRUE(isLog)) {
            assert(
                allArePositive(data[["x"]]),
                allArePositive(data[["y"]])
            )
        }
        if (isTRUE(isLog)) {
            base <- switch(EXPR = trans, "log2" = 2L, "log10" = 10L)
            limits <- list(
                "x" = c(
                    base ^ min(floor(log(data[["x"]], base = base))),
                    base ^ max(ceiling(log(data[["x"]], base = base)))
                ),
                "y" = c(
                    base ^ min(floor(log(data[["y"]], base = base))),
                    base ^ max(ceiling(log(data[["y"]], base = base)))
                )
            )
            assert(!any(unlist(limits) == 0L))
            breaks <- list(
                "x" = base ^ seq(
                    from = log(limits[["x"]][[1L]], base = base),
                    to = log(limits[["x"]][[2L]], base = base),
                    by = 1L
                ),
                "y" = base ^ seq(
                    from = log(limits[["y"]][[1L]], base = base),
                    to = log(limits[["y"]][[2L]], base = base),
                    by = 1L
                )
            )
        }
        args <- list("x" = sym("x"), "y" = sym("y"))
        if (isTRUE(label)) {
            args[["label"]] <- sym("label")
        }
        mapping <- do.call(what = aes, args = args)
        formula <- y ~ x
        p <- ggplot(data = data, mapping = mapping) +
            geom_point(color = colors[["dots"]]) +
            geom_smooth(
                method = "lm",
                formula = formula,
                se = TRUE,
                color = colors[["line"]],
                fill = colors[["se"]]
            )
        if (isTRUE(r2)) {
            requireNamespaces("ggpmisc")
            p <- p + ggpmisc::stat_poly_eq(
                mapping = aes(label = paste(
                    stat(!!sym("eq.label")),
                    stat(!!sym("rr.label")),
                    sep = "*\", \"*"
                )),
                formula = formula,
                parse = TRUE
            )
        }
        p <- p + labs
        if (isTRUE(isLog)) {
            p <- p +
                scale_x_continuous(
                    trans = trans,
                    breaks = breaks[["x"]],
                    limits = limits[["x"]],
                    labels = comma
                ) +
                scale_y_continuous(
                    trans = trans,
                    breaks = breaks[["y"]],
                    limits = limits[["y"]],
                    labels = comma
                ) +
                annotation_logticks(
                    base = base,
                    sides = "bl"
                )
        }
        if (isTRUE(label)) {
            p <- p + acid_geom_label_repel()
        }
        p
    }



#' @rdname plotCorrelation
#' @export
setMethod(
    f = "plotCorrelation",
    signature = signature("matrix"),
    definition = `plotCorrelation,matrix`
)



## Updated 2021-02-09.
`plotCorrelation,Matrix` <-  # nolint
    `plotCorrelation,matrix`



#' @rdname plotCorrelation
#' @export
setMethod(
    f = "plotCorrelation",
    signature = signature("Matrix"),
    definition = `plotCorrelation,Matrix`
)



## Updated 2021-05-17.
`plotCorrelation,data.frame` <-  # nolint
    function(object, labelCol = NULL, ...) {
        assert(isString(labelCol, nullOK = TRUE))
        mat <- as.matrix(object)
        if (isString(labelCol)) {
            rn <- object[[labelCol]]
            rn <- as.character(rn)
            assert(hasNoDuplicates(rn))
            rownames(mat) <- rn
        }
        plotCorrelation(
            object = mat,
            label = isString(labelCol),
            ...
        )
    }



#' @rdname plotCorrelation
#' @export
setMethod(
    f = "plotCorrelation",
    signature = signature("data.frame"),
    definition = `plotCorrelation,data.frame`
)



## Updated 2021-02-09.
`plotCorrelation,DataFrame` <-  # nolint
    `plotCorrelation,data.frame`



#' @rdname plotCorrelation
#' @export
setMethod(
    f = "plotCorrelation",
    signature = signature("DataFrame"),
    definition = `plotCorrelation,DataFrame`
)



## Updated 2021-08-09.
`plotCorrelation,SE` <-  # nolint
    function(
        object,
        assay = 1L,
        ...
    ) {
        validObject(object)
        assert(isString(assay) || isInt(assay))
        assay <- assay(x = object, i = assay)
        plotCorrelation(object = assay, ...)
    }



#' @rdname plotCorrelation
#' @export
setMethod(
    f = "plotCorrelation",
    signature = signature("SummarizedExperiment"),
    definition = `plotCorrelation,SE`
)
